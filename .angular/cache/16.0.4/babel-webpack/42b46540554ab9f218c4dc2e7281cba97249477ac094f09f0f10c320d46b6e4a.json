{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { inject, forwardRef, ElementRef, Directive, EventEmitter, Renderer2, NgZone, Input, Output, HostBinding, HostListener, ContentChild, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nconst DROP_EFFECTS = ['move', 'copy', 'link'];\nconst CUSTOM_MIME_TYPE = 'application/x-dnd';\nconst JSON_MIME_TYPE = 'application/json';\nconst MSIE_MIME_TYPE = 'Text';\nfunction mimeTypeIsCustom(mimeType) {\n  return mimeType.substr(0, CUSTOM_MIME_TYPE.length) === CUSTOM_MIME_TYPE;\n}\nfunction getWellKnownMimeType(event) {\n  if (event.dataTransfer) {\n    const types = event.dataTransfer.types;\n    // IE 9 workaround.\n    if (!types) {\n      return MSIE_MIME_TYPE;\n    }\n    for (let i = 0; i < types.length; i++) {\n      if (types[i] === MSIE_MIME_TYPE || types[i] === JSON_MIME_TYPE || mimeTypeIsCustom(types[i])) {\n        return types[i];\n      }\n    }\n  }\n  return null;\n}\nfunction setDragData(event, data, effectAllowed) {\n  // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n  // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n  const mimeType = CUSTOM_MIME_TYPE + (data.type ? '-' + data.type : '');\n  const dataString = JSON.stringify(data);\n  try {\n    event.dataTransfer?.setData(mimeType, dataString);\n  } catch (e) {\n    //   Setting a custom MIME type did not work, we are probably in IE or Edge.\n    try {\n      event.dataTransfer?.setData(JSON_MIME_TYPE, dataString);\n    } catch (e) {\n      //   We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n      //   does not allow changing the cursor in the dragover event, therefore we have to choose\n      //   the one we want to display now by setting effectAllowed.\n      const effectsAllowed = filterEffects(DROP_EFFECTS, effectAllowed);\n      if (event.dataTransfer) {\n        event.dataTransfer.effectAllowed = effectsAllowed[0];\n      }\n      event.dataTransfer?.setData(MSIE_MIME_TYPE, dataString);\n    }\n  }\n}\nfunction getDropData(event, dragIsExternal) {\n  // check if the mime type is well known\n  const mimeType = getWellKnownMimeType(event);\n  // drag did not originate from [dndDraggable]\n  if (dragIsExternal === true) {\n    if (mimeType !== null && mimeTypeIsCustom(mimeType)) {\n      // the type of content is well known and safe to handle\n      return JSON.parse(event.dataTransfer?.getData(mimeType) ?? '{}');\n    }\n    // the contained data is unknown, let user handle it\n    return {};\n  }\n  if (mimeType !== null) {\n    // the type of content is well known and safe to handle\n    return JSON.parse(event.dataTransfer?.getData(mimeType) ?? '{}');\n  }\n  // the contained data is unknown, let user handle it\n  return {};\n}\nfunction filterEffects(effects, allowed) {\n  if (allowed === 'all' || allowed === 'uninitialized') {\n    return effects;\n  }\n  return effects.filter(function (effect) {\n    return allowed.toLowerCase().indexOf(effect) !== -1;\n  });\n}\nfunction getDirectChildElement(parentElement, childElement) {\n  let directChild = childElement;\n  while (directChild.parentNode !== parentElement) {\n    // reached root node without finding given parent\n    if (!directChild.parentNode) {\n      return null;\n    }\n    directChild = directChild.parentNode;\n  }\n  return directChild;\n}\nfunction shouldPositionPlaceholderBeforeElement(event, element, horizontal) {\n  const bounds = element.getBoundingClientRect();\n  // If the pointer is in the upper half of the list item element,\n  // we position the placeholder before the list item, otherwise after it.\n  if (horizontal) {\n    return event.clientX < bounds.left + bounds.width / 2;\n  }\n  return event.clientY < bounds.top + bounds.height / 2;\n}\nfunction calculateDragImageOffset(event, dragImage) {\n  const dragImageComputedStyle = window.getComputedStyle(dragImage);\n  const paddingTop = parseFloat(dragImageComputedStyle.paddingTop) || 0;\n  const paddingLeft = parseFloat(dragImageComputedStyle.paddingLeft) || 0;\n  const borderTop = parseFloat(dragImageComputedStyle.borderTopWidth) || 0;\n  const borderLeft = parseFloat(dragImageComputedStyle.borderLeftWidth) || 0;\n  return {\n    x: event.offsetX + paddingLeft + borderLeft,\n    y: event.offsetY + paddingTop + borderTop\n  };\n}\nfunction setDragImage(event, dragImage, offsetFunction) {\n  const offset = offsetFunction(event, dragImage) || {\n    x: 0,\n    y: 0\n  };\n  event.dataTransfer.setDragImage(dragImage, offset.x, offset.y);\n}\nconst _dndState = {\n  isDragging: false,\n  dropEffect: 'none',\n  effectAllowed: 'all',\n  type: undefined\n};\nfunction startDrag(event, effectAllowed, type) {\n  _dndState.isDragging = true;\n  _dndState.dropEffect = 'none';\n  _dndState.effectAllowed = effectAllowed;\n  _dndState.type = type;\n  if (event.dataTransfer) {\n    event.dataTransfer.effectAllowed = effectAllowed;\n  }\n}\nfunction endDrag() {\n  _dndState.isDragging = false;\n  _dndState.dropEffect = undefined;\n  _dndState.effectAllowed = undefined;\n  _dndState.type = undefined;\n}\nfunction setDropEffect(event, dropEffect) {\n  if (_dndState.isDragging === true) {\n    _dndState.dropEffect = dropEffect;\n  }\n  if (event.dataTransfer) {\n    event.dataTransfer.dropEffect = dropEffect;\n  }\n}\nfunction getDropEffect(event, effectAllowed) {\n  const dataTransferEffectAllowed = event.dataTransfer ? event.dataTransfer.effectAllowed : 'uninitialized';\n  let effects = filterEffects(DROP_EFFECTS, dataTransferEffectAllowed);\n  if (_dndState.isDragging === true) {\n    effects = filterEffects(effects, _dndState.effectAllowed);\n  }\n  if (effectAllowed) {\n    effects = filterEffects(effects, effectAllowed);\n  }\n  // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n  // therefore the following modifier keys will only affect other operating systems.\n  if (effects.length === 0) {\n    return 'none';\n  }\n  if (event.ctrlKey && effects.indexOf('copy') !== -1) {\n    return 'copy';\n  }\n  if (event.altKey && effects.indexOf('link') !== -1) {\n    return 'link';\n  }\n  return effects[0];\n}\nfunction getDndType(event) {\n  if (_dndState.isDragging === true) {\n    return _dndState.type;\n  }\n  const mimeType = getWellKnownMimeType(event);\n  if (mimeType === null) {\n    return undefined;\n  }\n  if (mimeType === MSIE_MIME_TYPE || mimeType === JSON_MIME_TYPE) {\n    return undefined;\n  }\n  return mimeType.substr(CUSTOM_MIME_TYPE.length + 1) || undefined;\n}\nfunction isExternalDrag() {\n  return _dndState.isDragging === false;\n}\nconst dndState = _dndState;\nlet DndDragImageRefDirective = /*#__PURE__*/(() => {\n  class DndDragImageRefDirective {\n    constructor() {\n      this.dndDraggableDirective = inject(forwardRef(() => DndDraggableDirective));\n      this.elementRef = inject(ElementRef);\n    }\n    ngOnInit() {\n      this.dndDraggableDirective.registerDragImage(this.elementRef);\n    }\n  }\n  DndDragImageRefDirective.ɵfac = function DndDragImageRefDirective_Factory(t) {\n    return new (t || DndDragImageRefDirective)();\n  };\n  DndDragImageRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndDragImageRefDirective,\n    selectors: [[\"\", \"dndDragImageRef\", \"\"]]\n  });\n  return DndDragImageRefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DndDraggableDirective = /*#__PURE__*/(() => {\n  class DndDraggableDirective {\n    constructor() {\n      this.dndEffectAllowed = 'copy';\n      this.dndDraggingClass = 'dndDragging';\n      this.dndDraggingSourceClass = 'dndDraggingSource';\n      this.dndDraggableDisabledClass = 'dndDraggableDisabled';\n      this.dndDragImageOffsetFunction = calculateDragImageOffset;\n      this.dndStart = new EventEmitter();\n      this.dndDrag = new EventEmitter();\n      this.dndEnd = new EventEmitter();\n      this.dndMoved = new EventEmitter();\n      this.dndCopied = new EventEmitter();\n      this.dndLinked = new EventEmitter();\n      this.dndCanceled = new EventEmitter();\n      this.draggable = true;\n      this.isDragStarted = false;\n      this.elementRef = inject(ElementRef);\n      this.renderer = inject(Renderer2);\n      this.ngZone = inject(NgZone);\n      this.dragEventHandler = event => this.onDrag(event);\n    }\n    set dndDisableIf(value) {\n      this.draggable = !value;\n      if (this.draggable) {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n      } else {\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggableDisabledClass);\n      }\n    }\n    set dndDisableDragIf(value) {\n      this.dndDisableIf = value;\n    }\n    ngAfterViewInit() {\n      this.ngZone.runOutsideAngular(() => {\n        this.elementRef.nativeElement.addEventListener('drag', this.dragEventHandler);\n      });\n    }\n    ngOnDestroy() {\n      this.elementRef.nativeElement.removeEventListener('drag', this.dragEventHandler);\n      if (this.isDragStarted) {\n        endDrag();\n      }\n    }\n    onDragStart(event) {\n      if (!this.draggable) {\n        return false;\n      }\n      // check if there is dnd handle and if the dnd handle was used to start the drag\n      if (this.dndHandle != null && event._dndUsingHandle == null) {\n        event.stopPropagation();\n        return false;\n      }\n      // initialize global state\n      startDrag(event, this.dndEffectAllowed, this.dndType);\n      this.isDragStarted = true;\n      setDragData(event, {\n        data: this.dndDraggable,\n        type: this.dndType\n      }, dndState.effectAllowed);\n      this.dragImage = this.determineDragImage();\n      // set dragging css class prior to setDragImage so styles are applied before\n      // TODO breaking change: add class to elementRef rather than drag image which could be another element\n      this.renderer.addClass(this.dragImage, this.dndDraggingClass);\n      // set custom dragimage if present\n      // set dragimage if drag is started from dndHandle\n      if (this.dndDragImageElementRef != null || event._dndUsingHandle != null) {\n        setDragImage(event, this.dragImage, this.dndDragImageOffsetFunction);\n      }\n      // add dragging source css class on first drag event\n      const unregister = this.renderer.listen(this.elementRef.nativeElement, 'drag', () => {\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n        unregister();\n      });\n      this.dndStart.emit(event);\n      event.stopPropagation();\n      setTimeout(() => {\n        this.renderer.setStyle(this.dragImage, 'pointer-events', 'none');\n      }, 100);\n      return true;\n    }\n    onDrag(event) {\n      this.dndDrag.emit(event);\n    }\n    onDragEnd(event) {\n      // get drop effect from custom stored state as its not reliable across browsers\n      const dropEffect = dndState.dropEffect;\n      this.renderer.setStyle(this.dragImage, 'pointer-events', 'unset');\n      let dropEffectEmitter;\n      switch (dropEffect) {\n        case 'copy':\n          dropEffectEmitter = this.dndCopied;\n          break;\n        case 'link':\n          dropEffectEmitter = this.dndLinked;\n          break;\n        case 'move':\n          dropEffectEmitter = this.dndMoved;\n          break;\n        default:\n          dropEffectEmitter = this.dndCanceled;\n          break;\n      }\n      dropEffectEmitter.emit(event);\n      this.dndEnd.emit(event);\n      // reset global state\n      endDrag();\n      this.isDragStarted = false;\n      this.renderer.removeClass(this.dragImage, this.dndDraggingClass);\n      // IE9 special hammering\n      window.setTimeout(() => {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDraggingSourceClass);\n      }, 0);\n      event.stopPropagation();\n    }\n    registerDragHandle(handle) {\n      this.dndHandle = handle;\n    }\n    registerDragImage(elementRef) {\n      this.dndDragImageElementRef = elementRef;\n    }\n    determineDragImage() {\n      // evaluate custom drag image existence\n      if (typeof this.dndDragImageElementRef !== 'undefined') {\n        return this.dndDragImageElementRef.nativeElement;\n      } else {\n        return this.elementRef.nativeElement;\n      }\n    }\n  }\n  DndDraggableDirective.ɵfac = function DndDraggableDirective_Factory(t) {\n    return new (t || DndDraggableDirective)();\n  };\n  DndDraggableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndDraggableDirective,\n    selectors: [[\"\", \"dndDraggable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function DndDraggableDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dragstart\", function DndDraggableDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragStart($event);\n        })(\"dragend\", function DndDraggableDirective_dragend_HostBindingHandler($event) {\n          return ctx.onDragEnd($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"draggable\", ctx.draggable);\n      }\n    },\n    inputs: {\n      dndDraggable: \"dndDraggable\",\n      dndEffectAllowed: \"dndEffectAllowed\",\n      dndType: \"dndType\",\n      dndDraggingClass: \"dndDraggingClass\",\n      dndDraggingSourceClass: \"dndDraggingSourceClass\",\n      dndDraggableDisabledClass: \"dndDraggableDisabledClass\",\n      dndDragImageOffsetFunction: \"dndDragImageOffsetFunction\",\n      dndDisableIf: \"dndDisableIf\",\n      dndDisableDragIf: \"dndDisableDragIf\"\n    },\n    outputs: {\n      dndStart: \"dndStart\",\n      dndDrag: \"dndDrag\",\n      dndEnd: \"dndEnd\",\n      dndMoved: \"dndMoved\",\n      dndCopied: \"dndCopied\",\n      dndLinked: \"dndLinked\",\n      dndCanceled: \"dndCanceled\"\n    }\n  });\n  return DndDraggableDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DndPlaceholderRefDirective = /*#__PURE__*/(() => {\n  class DndPlaceholderRefDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n    ngOnInit() {\n      // placeholder has to be \"invisible\" to the cursor, or it would interfere with the dragover detection for the same dropzone\n      this.elementRef.nativeElement.style.pointerEvents = 'none';\n    }\n  }\n  DndPlaceholderRefDirective.ɵfac = function DndPlaceholderRefDirective_Factory(t) {\n    return new (t || DndPlaceholderRefDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  DndPlaceholderRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndPlaceholderRefDirective,\n    selectors: [[\"\", \"dndPlaceholderRef\", \"\"]]\n  });\n  return DndPlaceholderRefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DndDropzoneDirective = /*#__PURE__*/(() => {\n  class DndDropzoneDirective {\n    constructor(ngZone, elementRef, renderer) {\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.dndDropzone = '';\n      this.dndEffectAllowed = 'uninitialized';\n      this.dndAllowExternal = false;\n      this.dndHorizontal = false;\n      this.dndDragoverClass = 'dndDragover';\n      this.dndDropzoneDisabledClass = 'dndDropzoneDisabled';\n      this.dndDragover = new EventEmitter();\n      this.dndDrop = new EventEmitter();\n      this.placeholder = null;\n      this.disabled = false;\n      this.dragEnterEventHandler = event => this.onDragEnter(event);\n      this.dragOverEventHandler = event => this.onDragOver(event);\n      this.dragLeaveEventHandler = event => this.onDragLeave(event);\n    }\n    set dndDisableIf(value) {\n      this.disabled = value;\n      if (this.disabled) {\n        this.renderer.addClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n      } else {\n        this.renderer.removeClass(this.elementRef.nativeElement, this.dndDropzoneDisabledClass);\n      }\n    }\n    set dndDisableDropIf(value) {\n      this.dndDisableIf = value;\n    }\n    ngAfterViewInit() {\n      this.placeholder = this.tryGetPlaceholder();\n      this.removePlaceholderFromDOM();\n      this.ngZone.runOutsideAngular(() => {\n        this.elementRef.nativeElement.addEventListener('dragenter', this.dragEnterEventHandler);\n        this.elementRef.nativeElement.addEventListener('dragover', this.dragOverEventHandler);\n        this.elementRef.nativeElement.addEventListener('dragleave', this.dragLeaveEventHandler);\n      });\n    }\n    ngOnDestroy() {\n      this.elementRef.nativeElement.removeEventListener('dragenter', this.dragEnterEventHandler);\n      this.elementRef.nativeElement.removeEventListener('dragover', this.dragOverEventHandler);\n      this.elementRef.nativeElement.removeEventListener('dragleave', this.dragLeaveEventHandler);\n    }\n    onDragEnter(event) {\n      // check if another dropzone is activated\n      if (event._dndDropzoneActive === true) {\n        this.cleanupDragoverState();\n        return;\n      }\n      // set as active if the target element is inside this dropzone\n      if (event._dndDropzoneActive == null) {\n        const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n        if (this.elementRef.nativeElement.contains(newTarget)) {\n          event._dndDropzoneActive = true;\n        }\n      }\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType(event);\n      if (!this.isDropAllowed(type)) {\n        return;\n      }\n      // allow the dragenter\n      event.preventDefault();\n    }\n    onDragOver(event) {\n      // With nested dropzones, we want to ignore this event if a child dropzone\n      // has already handled a dragover.  Historically, event.stopPropagation() was\n      // used to prevent this bubbling, but that prevents any dragovers outside the\n      // ngx-drag-drop component, and stops other use cases such as scrolling on drag.\n      // Instead, we can check if the event was already prevented by a child and bail early.\n      if (event.defaultPrevented) {\n        return;\n      }\n      // check if this drag event is allowed to drop on this dropzone\n      const type = getDndType(event);\n      if (!this.isDropAllowed(type)) {\n        return;\n      }\n      this.checkAndUpdatePlaceholderPosition(event);\n      const dropEffect = getDropEffect(event, this.dndEffectAllowed);\n      if (dropEffect === 'none') {\n        this.cleanupDragoverState();\n        return;\n      }\n      // allow the dragover\n      event.preventDefault();\n      // set the drop effect\n      setDropEffect(event, dropEffect);\n      this.dndDragover.emit(event);\n      this.renderer.addClass(this.elementRef.nativeElement, this.dndDragoverClass);\n    }\n    onDrop(event) {\n      try {\n        // check if this drag event is allowed to drop on this dropzone\n        const type = getDndType(event);\n        if (!this.isDropAllowed(type)) {\n          return;\n        }\n        const data = getDropData(event, isExternalDrag());\n        if (!this.isDropAllowed(data.type)) {\n          return;\n        }\n        // signal custom drop handling\n        event.preventDefault();\n        const dropEffect = getDropEffect(event);\n        setDropEffect(event, dropEffect);\n        if (dropEffect === 'none') {\n          return;\n        }\n        const dropIndex = this.getPlaceholderIndex();\n        // if for whatever reason the placeholder is not present in the DOM but it should be there\n        // we don't allow/emit the drop event since it breaks the contract\n        // seems to only happen if drag and drop is executed faster than the DOM updates\n        if (dropIndex === -1) {\n          return;\n        }\n        this.dndDrop.emit({\n          event: event,\n          dropEffect: dropEffect,\n          isExternal: isExternalDrag(),\n          data: data.data,\n          index: dropIndex,\n          type: type\n        });\n        event.stopPropagation();\n      } finally {\n        this.cleanupDragoverState();\n      }\n    }\n    onDragLeave(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      // check if still inside this dropzone and not yet handled by another dropzone\n      if (event._dndDropzoneActive == null) {\n        const newTarget = document.elementFromPoint(event.clientX, event.clientY);\n        if (this.elementRef.nativeElement.contains(newTarget)) {\n          event._dndDropzoneActive = true;\n          return;\n        }\n      }\n      this.cleanupDragoverState();\n      // cleanup drop effect when leaving dropzone\n      setDropEffect(event, 'none');\n    }\n    isDropAllowed(type) {\n      // dropzone is disabled -> deny it\n      if (this.disabled) {\n        return false;\n      }\n      // if drag did not start from our directive\n      // and external drag sources are not allowed -> deny it\n      if (isExternalDrag() && !this.dndAllowExternal) {\n        return false;\n      }\n      // no filtering by types -> allow it\n      if (!this.dndDropzone) {\n        return true;\n      }\n      // no type set -> allow it\n      if (!type) {\n        return true;\n      }\n      if (!Array.isArray(this.dndDropzone)) {\n        throw new Error('dndDropzone: bound value to [dndDropzone] must be an array!');\n      }\n      // if dropzone contains type -> allow it\n      return this.dndDropzone.indexOf(type) !== -1;\n    }\n    tryGetPlaceholder() {\n      if (typeof this.dndPlaceholderRef !== 'undefined') {\n        return this.dndPlaceholderRef.elementRef.nativeElement;\n      }\n      // TODO nasty workaround needed because if ng-container / template is used @ContentChild() or DI will fail because\n      // of wrong context see angular bug https://github.com/angular/angular/issues/13517\n      return this.elementRef.nativeElement.querySelector('[dndPlaceholderRef]');\n    }\n    removePlaceholderFromDOM() {\n      if (this.placeholder !== null && this.placeholder.parentNode !== null) {\n        this.placeholder.parentNode.removeChild(this.placeholder);\n      }\n    }\n    checkAndUpdatePlaceholderPosition(event) {\n      if (this.placeholder === null) {\n        return;\n      }\n      // make sure the placeholder is in the DOM\n      if (this.placeholder.parentNode !== this.elementRef.nativeElement) {\n        this.renderer.appendChild(this.elementRef.nativeElement, this.placeholder);\n      }\n      // update the position if the event originates from a child element of the dropzone\n      const directChild = getDirectChildElement(this.elementRef.nativeElement, event.target);\n      // early exit if no direct child or direct child is placeholder\n      if (directChild === null || directChild === this.placeholder) {\n        return;\n      }\n      const positionPlaceholderBeforeDirectChild = shouldPositionPlaceholderBeforeElement(event, directChild, this.dndHorizontal);\n      if (positionPlaceholderBeforeDirectChild) {\n        // do insert before only if necessary\n        if (directChild.previousSibling !== this.placeholder) {\n          this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild);\n        }\n      } else {\n        // do insert after only if necessary\n        if (directChild.nextSibling !== this.placeholder) {\n          this.renderer.insertBefore(this.elementRef.nativeElement, this.placeholder, directChild.nextSibling);\n        }\n      }\n    }\n    getPlaceholderIndex() {\n      if (this.placeholder === null) {\n        return undefined;\n      }\n      const element = this.elementRef.nativeElement;\n      return Array.prototype.indexOf.call(element.children, this.placeholder);\n    }\n    cleanupDragoverState() {\n      this.renderer.removeClass(this.elementRef.nativeElement, this.dndDragoverClass);\n      this.removePlaceholderFromDOM();\n    }\n  }\n  DndDropzoneDirective.ɵfac = function DndDropzoneDirective_Factory(t) {\n    return new (t || DndDropzoneDirective)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  DndDropzoneDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndDropzoneDirective,\n    selectors: [[\"\", \"dndDropzone\", \"\"]],\n    contentQueries: function DndDropzoneDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DndPlaceholderRefDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dndPlaceholderRef = _t.first);\n      }\n    },\n    hostBindings: function DndDropzoneDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"drop\", function DndDropzoneDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      dndDropzone: \"dndDropzone\",\n      dndEffectAllowed: \"dndEffectAllowed\",\n      dndAllowExternal: \"dndAllowExternal\",\n      dndHorizontal: \"dndHorizontal\",\n      dndDragoverClass: \"dndDragoverClass\",\n      dndDropzoneDisabledClass: \"dndDropzoneDisabledClass\",\n      dndDisableIf: \"dndDisableIf\",\n      dndDisableDropIf: \"dndDisableDropIf\"\n    },\n    outputs: {\n      dndDragover: \"dndDragover\",\n      dndDrop: \"dndDrop\"\n    }\n  });\n  return DndDropzoneDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DndHandleDirective = /*#__PURE__*/(() => {\n  class DndHandleDirective {\n    constructor() {\n      this.draggable = true;\n      this.dndDraggableDirective = inject(DndDraggableDirective);\n    }\n    ngOnInit() {\n      this.dndDraggableDirective.registerDragHandle(this);\n    }\n    onDragEvent(event) {\n      event._dndUsingHandle = true;\n    }\n  }\n  DndHandleDirective.ɵfac = function DndHandleDirective_Factory(t) {\n    return new (t || DndHandleDirective)();\n  };\n  DndHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndHandleDirective,\n    selectors: [[\"\", \"dndHandle\", \"\"]],\n    hostVars: 1,\n    hostBindings: function DndHandleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"dragstart\", function DndHandleDirective_dragstart_HostBindingHandler($event) {\n          return ctx.onDragEvent($event);\n        })(\"dragend\", function DndHandleDirective_dragend_HostBindingHandler($event) {\n          return ctx.onDragEvent($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"draggable\", ctx.draggable);\n      }\n    }\n  });\n  return DndHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DndModule = /*#__PURE__*/(() => {\n  class DndModule {}\n  DndModule.ɵfac = function DndModule_Factory(t) {\n    return new (t || DndModule)();\n  };\n  DndModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DndModule\n  });\n  DndModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return DndModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of dnd\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DndDragImageRefDirective, DndDraggableDirective, DndDropzoneDirective, DndHandleDirective, DndModule, DndPlaceholderRefDirective };\n//# sourceMappingURL=ngx-drag-drop.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}