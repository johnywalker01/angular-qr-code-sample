{"ast":null,"code":"import _asyncToGenerator from \"D:/Schneider_Electric_France/trial/angular-qr-code-sample/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { Injectable, EventEmitter, Component, ViewChild, ViewEncapsulation, NgModule } from '@angular/core';\nimport { AsyncSubject, BehaviorSubject } from 'rxjs';\nconst _c0 = [\"video\"];\nconst _c1 = [\"canvas\"];\nconst _c2 = [\"resultsPanel\"];\nconst WASMPROJECT = \"assets/wasm/index.js\";\nconst WASMREMOTE = \"https://cdn.jsdelivr.net/npm/ngx-scanner-qrcode@1.4.2/wasm/index.js\";\nconst WASMREMOTELATEST = \"https://cdn.jsdelivr.net/npm/ngx-scanner-qrcode@latest/wasm/index.js\";\nconst MEDIA_STREAM_DEFAULT = {\n  audio: false,\n  video: true\n};\nconst CONFIG_DEFAULT = {\n  src: '',\n  fps: 30,\n  vibrate: 300,\n  decode: 'utf-8',\n  isBeep: true,\n  constraints: MEDIA_STREAM_DEFAULT,\n  canvasStyles: {\n    font: '15px serif',\n    lineWidth: 1,\n    strokeStyle: 'green',\n    fillStyle: '#55f02880'\n  }\n};\n\n/**\n * OVERRIDES\n * @param variableKey\n * @param config\n * @param defaultConfig\n * @returns\n */\nconst OVERRIDES = (variableKey, config, defaultConfig) => {\n  if (config && Object.keys(config[variableKey]).length) {\n    for (const key in defaultConfig) {\n      const cloneDeep = JSON.parse(JSON.stringify({\n        ...config[variableKey],\n        ...{\n          [key]: defaultConfig[key]\n        }\n      }));\n      config[variableKey] = config[variableKey].hasOwnProperty(key) ? config[variableKey] : cloneDeep;\n    }\n    return config[variableKey];\n  } else {\n    return defaultConfig;\n  }\n};\n/**\n * Rxjs complete\n * @param as\n * @param data\n * @param error\n */\nconst AS_COMPLETE = (as, data, error) => {\n  error ? as.error(error) : as.next(data);\n  as.complete();\n};\n/**\n * CAMERA_BEEP\n * @param isPlay\n * @returns\n */\nconst PLAY_AUDIO = (isPlay = false) => {\n  if (isPlay === false) return;\n  const audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU' + Array(300).join('101'));\n  // when the sound has been loaded, execute your code\n  audio.oncanplaythrough = () => {\n    const promise = audio.play();\n    if (promise) {\n      promise.catch(e => {\n        if (e.name === \"NotAllowedError\" || e.name === \"NotSupportedError\") {\n          // console.log(e.name);\n        }\n      });\n    }\n  };\n};\n/**\n * DRAW_RESULT_APPEND_CHILD\n * @param code\n * @param oriCanvas\n * @param elTarget\n * @param canvasStyles\n */\nconst DRAW_RESULT_APPEND_CHILD = (code, oriCanvas, elTarget, canvasStyles) => {\n  let widthZoom;\n  let heightZoom;\n  let oriWidth = oriCanvas.width;\n  let oriHeight = oriCanvas.height;\n  let oriWHRatio = oriWidth / oriHeight;\n  let imgWidth = parseInt(getComputedStyle(oriCanvas).width);\n  let imgHeight = parseInt(getComputedStyle(oriCanvas).height);\n  let imgWHRatio = imgWidth / imgHeight;\n  elTarget.innerHTML = '';\n  if (oriWHRatio > imgWHRatio) {\n    widthZoom = imgWidth / oriWidth;\n    heightZoom = imgWidth / oriWHRatio / oriHeight;\n  } else {\n    heightZoom = imgHeight / oriHeight;\n    widthZoom = imgHeight * oriWHRatio / oriWidth;\n  }\n  for (let i = 0; i < code.length; i++) {\n    const _code = code[i];\n    // New canvas\n    let cvs = document.createElement(\"canvas\");\n    let ctx = cvs.getContext('2d', {\n      willReadFrequently: true\n    });\n    let loc = {};\n    let X = [];\n    let Y = [];\n    let fontSize = 0;\n    let svgSize = 0;\n    let num = canvasStyles?.font?.replace(/[^0-9]/g, '');\n    if (/[0-9]/g.test(num)) {\n      fontSize = parseFloat(num);\n      svgSize = (widthZoom || 1) * fontSize;\n      if (Number.isNaN(svgSize)) {\n        svgSize = fontSize;\n      }\n    }\n    // Point x,y\n    const points = _code.points;\n    for (let j = 0; j < points.length; j++) {\n      const xj = points?.[j]?.x ?? 0;\n      const yj = points?.[j]?.y ?? 0;\n      loc[`x${j + 1}`] = xj;\n      loc[`y${j + 1}`] = yj;\n      X.push(xj);\n      Y.push(yj);\n    }\n    // Min max\n    let maxX = Math.max(...X);\n    let minX = Math.min(...X);\n    let maxY = Math.max(...Y);\n    let minY = Math.min(...Y);\n    // Add class\n    cvs.setAttribute('class', 'qrcode-polygon');\n    // Size with screen zoom\n    if (oriWHRatio > imgWHRatio) {\n      cvs.style.top = minY * heightZoom + (imgHeight - imgWidth / oriWHRatio) * 0.5 + \"px\";\n      cvs.style.left = minX * widthZoom + \"px\";\n      cvs.width = (maxX - minX) * widthZoom;\n      cvs.height = (maxY - minY) * widthZoom;\n    } else {\n      cvs.style.top = minY * heightZoom + \"px\";\n      cvs.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n      cvs.width = (maxX - minX) * heightZoom;\n      cvs.height = (maxY - minY) * heightZoom;\n    }\n    // Style for canvas\n    for (const key in canvasStyles) {\n      ctx[key] = canvasStyles[key];\n    }\n    // polygon [x,y, x,y, x,y.....];\n    const polygon = [];\n    for (let k = 0; k < X.length; k++) {\n      polygon.push((loc[`x${k + 1}`] - minX) * heightZoom);\n      polygon.push((loc[`y${k + 1}`] - minY) * widthZoom);\n    }\n    // Copy array\n    const shape = polygon.slice(0);\n    // Draw polygon\n    ctx.beginPath();\n    ctx.moveTo(shape.shift(), shape.shift());\n    while (shape.length) {\n      ctx.lineTo(shape.shift(), shape.shift()); //x,y\n    }\n\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    if (fontSize) {\n      // Tooltip result\n      const qrcodeTooltipTemp = document.createElement('div');\n      qrcodeTooltipTemp.setAttribute('class', 'qrcode-tooltip-temp');\n      qrcodeTooltipTemp.innerText = _code.value;\n      const xmlString = `<?xml version=\"1.0\" encoding=\"utf-8\"?><svg version=\"1.1\" class=\"qrcode-tooltip-clipboard\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"${svgSize}\" height=\"${svgSize}\" x=\"0px\" y=\"0px\" viewBox=\"0 0 115.77 122.88\" xml:space=\"preserve\"><g><path d=\"M89.62,13.96v7.73h12.19h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02v0.02 v73.27v0.01h-0.02c-0.01,3.84-1.57,7.33-4.1,9.86c-2.51,2.5-5.98,4.06-9.82,4.07v0.02h-0.02h-61.7H40.1v-0.02 c-3.84-0.01-7.34-1.57-9.86-4.1c-2.5-2.51-4.06-5.98-4.07-9.82h-0.02v-0.02V92.51H13.96h-0.01v-0.02c-3.84-0.01-7.34-1.57-9.86-4.1 c-2.5-2.51-4.06-5.98-4.07-9.82H0v-0.02V13.96v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07V0h0.02h61.7 h0.01v0.02c3.85,0.01,7.34,1.57,9.86,4.1c2.5,2.51,4.06,5.98,4.07,9.82h0.02V13.96L89.62,13.96z M79.04,21.69v-7.73v-0.02h0.02 c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v64.59v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h12.19V35.65 v-0.01h0.02c0.01-3.85,1.58-7.34,4.1-9.86c2.51-2.5,5.98-4.06,9.82-4.07v-0.02h0.02H79.04L79.04,21.69z M105.18,108.92V35.65v-0.02 h0.02c0-0.91-0.39-1.75-1.01-2.37c-0.61-0.61-1.46-1-2.37-1v0.02h-0.01h-61.7h-0.02v-0.02c-0.91,0-1.75,0.39-2.37,1.01 c-0.61,0.61-1,1.46-1,2.37h0.02v0.01v73.27v0.02h-0.02c0,0.91,0.39,1.75,1.01,2.37c0.61,0.61,1.46,1,2.37,1v-0.02h0.01h61.7h0.02 v0.02c0.91,0,1.75-0.39,2.37-1.01c0.61-0.61,1-1.46,1-2.37h-0.02V108.92L105.18,108.92z\"></path></g></svg> `;\n      const xmlDom = new DOMParser().parseFromString(xmlString, 'application/xml');\n      const svgDom = qrcodeTooltipTemp.ownerDocument.importNode(xmlDom.documentElement, true);\n      qrcodeTooltipTemp.appendChild(svgDom);\n      svgDom.addEventListener(\"click\", () => window.navigator['clipboard'].writeText(_code.value));\n      // Tooltip box\n      const qrcodeTooltip = document.createElement('div');\n      qrcodeTooltip.setAttribute('class', 'qrcode-tooltip');\n      qrcodeTooltip.appendChild(qrcodeTooltipTemp);\n      heightZoom = imgHeight / oriHeight;\n      widthZoom = imgHeight * oriWHRatio / oriWidth;\n      qrcodeTooltip.style.fontSize = widthZoom * fontSize + 'px';\n      qrcodeTooltip.style.top = minY * heightZoom + \"px\";\n      qrcodeTooltip.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n      qrcodeTooltip.style.width = (maxX - minX) * heightZoom + \"px\";\n      qrcodeTooltip.style.height = (maxY - minY) * heightZoom + \"px\";\n      // Result text\n      const resultText = document.createElement('span');\n      resultText.innerText = _code.value;\n      resultText.style.fontSize = widthZoom * fontSize + 'px';\n      // Set position result text\n      resultText.style.top = minY * heightZoom + -20 * heightZoom + \"px\";\n      resultText.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n      elTarget?.appendChild(qrcodeTooltip);\n      elTarget?.appendChild(resultText);\n    }\n    elTarget?.appendChild(cvs);\n  }\n  ;\n};\n/**\n * DRAW_RESULT_ON_CANVAS\n * @param code\n * @param cvs\n * @param canvasStyles\n */\nconst DRAW_RESULT_ON_CANVAS = (code, cvs, canvasStyles) => {\n  let ctx = cvs.getContext('2d', {\n    willReadFrequently: true\n  });\n  for (let i = 0; i < code.length; i++) {\n    const _code = code[i];\n    let loc = {};\n    let X = [];\n    let Y = [];\n    // Point x,y\n    const points = _code.points;\n    for (let j = 0; j < points.length; j++) {\n      const xj = points?.[j]?.x ?? 0;\n      const yj = points?.[j]?.y ?? 0;\n      loc[`x${j + 1}`] = xj;\n      loc[`y${j + 1}`] = yj;\n      X.push(xj);\n      Y.push(yj);\n    }\n    // Min max\n    let minX = Math.min(...X);\n    let minY = Math.min(...Y);\n    // Style for canvas\n    for (const key in canvasStyles) {\n      ctx[key] = canvasStyles[key];\n    }\n    ctx.font = canvasStyles?.font ?? `15px serif`;\n    FILL_TEXT_MULTI_LINE(ctx, _code.value, minX, minY - 5);\n    // polygon [x,y, x,y, x,y.....];\n    const polygon = [];\n    for (let k = 0; k < X.length; k++) {\n      polygon.push(loc[`x${k + 1}`]);\n      polygon.push(loc[`y${k + 1}`]);\n    }\n    // Copy array\n    const shape = polygon.slice(0);\n    // Draw polygon\n    ctx.beginPath();\n    ctx.moveTo(shape.shift(), shape.shift());\n    while (shape.length) {\n      ctx.lineTo(shape.shift(), shape.shift()); //x,y\n    }\n\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n  ;\n};\n/**\n * READ_AS_DATA_URL\n * @param file\n * @param config\n * @return Promise\n */\nconst READ_AS_DATA_URL = (file, configs) => {\n  /** overrides **/\n  let decode = configs?.decode ?? CONFIG_DEFAULT.decode;\n  let canvasStyles = configs?.canvasStyles ?? CONFIG_DEFAULT.canvasStyles;\n  let isBeep = configs?.isBeep ?? CONFIG_DEFAULT.isBeep;\n  /** drawImage **/\n  return new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      const objectFile = {\n        name: file.name,\n        file: file,\n        url: URL.createObjectURL(file)\n      };\n      // Set the src of this Image object.\n      const image = new Image();\n      // Setting cross origin value to anonymous\n      image.setAttribute('crossOrigin', 'anonymous');\n      // When our image has loaded.\n      image.onload = /*#__PURE__*/_asyncToGenerator(function* () {\n        // Get the canvas element by using the getElementById method.\n        const canvas = document.createElement('canvas');\n        // HTMLImageElement size\n        canvas.width = image.naturalWidth || image.width;\n        canvas.height = image.naturalHeight || image.height;\n        // Get a 2D drawing context for the canvas.\n        const ctx = canvas.getContext('2d');\n        // Draw image\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        // Data image\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Scanner\n        const code = yield zbarWasm.scanImageData(imageData);\n        if (code?.length) {\n          // Decode\n          code.forEach(s => s.value = s.decode(decode?.toLocaleLowerCase()));\n          // Overlay\n          DRAW_RESULT_ON_CANVAS(code, canvas, canvasStyles);\n          // Emit object\n          const blob = yield CANVAS_TO_BLOB(canvas);\n          const url = URL.createObjectURL(blob);\n          const blobToFile = (theBlob, fileName) => new File([theBlob], fileName, {\n            lastModified: new Date().getTime(),\n            type: theBlob.type\n          });\n          resolve(Object.assign({}, objectFile, {\n            data: code,\n            url: url,\n            canvas: canvas,\n            file: blobToFile(blob, objectFile.name)\n          }));\n          PLAY_AUDIO(isBeep);\n        } else {\n          resolve(Object.assign({}, objectFile, {\n            data: code,\n            canvas: canvas\n          }));\n        }\n      });\n      // Set src\n      image.src = objectFile.url;\n    };\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsDataURL(file);\n  });\n};\n/**\n * Convert canvas to blob\n * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality\n * @param canvas\n * @param type\n * @return Promise\n */\nconst CANVAS_TO_BLOB = (canvas, type) => {\n  return new Promise((resolve, reject) => canvas.toBlob(blob => resolve(blob), type));\n};\n/**\n * Convert blob to file\n * @param theBlob\n * @param fileName\n * @return File\n */\nconst BLOB_TO_FILE = (theBlob, fileName) => {\n  return new File([theBlob], fileName, {\n    lastModified: new Date().getTime(),\n    type: theBlob.type\n  });\n};\n/**\n * FILES_TO_SCAN\n * @param files\n * @param configs\n * @param as\n * @returns\n */\nconst FILES_TO_SCAN = (files = [], configs, as = new AsyncSubject()) => {\n  Promise.all(Object.assign([], files).map(m => READ_AS_DATA_URL(m, configs))).then(img => {\n    AS_COMPLETE(as, img);\n  }).catch(error => AS_COMPLETE(as, null, error));\n  return as;\n};\n/**\n * FILL_TEXT_MULTI_LINE\n * @param ctx\n * @param text\n * @param x\n * @param y\n */\nconst FILL_TEXT_MULTI_LINE = (ctx, text, x, y) => {\n  let lineHeight = ctx.measureText(\"M\").width * 1.2;\n  let lines = text.split(\"\\n\");\n  for (var i = 0; i < lines.length; ++i) {\n    ctx.fillText(lines[i], x, y);\n    ctx.strokeText(lines[i], x, y);\n    y += lineHeight;\n  }\n};\n/**\n * ADD_JS_TO_ELEMENT\n * @param as\n * @param renderer\n * @return AsyncSubject<boolean>\n */\nconst ADD_JS_TO_ELEMENT = (as, renderer) => {\n  const scriptRemote = document.querySelectorAll(`script[src=\"${WASMREMOTE}\"]`);\n  const scriptRemoteLatest = document.querySelectorAll(`script[src=\"${WASMREMOTELATEST}\"]`);\n  if (scriptRemote.length || scriptRemoteLatest.length) {\n    // Using wasmRemote\n    setTimeout(() => AS_COMPLETE(as, true), 200);\n  } else {\n    // Using wasmProject\n    const scriptProject = document.querySelectorAll(`script[src=\"${WASMPROJECT}\"]`);\n    if (scriptProject.length === 1) {\n      setTimeout(() => AS_COMPLETE(as, true), 200);\n    } else {\n      scriptProject.forEach(f => f.remove());\n      const script = renderer.createElement(\"script\");\n      renderer.setAttribute(script, \"type\", \"text/javascript\");\n      renderer.setAttribute(script, \"src\", WASMPROJECT);\n      renderer.appendChild(document.body, script);\n      script.onload = () => setTimeout(() => AS_COMPLETE(as, true), 200);\n      script.onerror = () => setTimeout(() => AS_COMPLETE(as, false, true), 200);\n    }\n  }\n  return as;\n};\n/**\n * REMOVE_CANVAS\n * @param element\n */\nconst REMOVE_CANVAS = element => {\n  Object.assign([], element.childNodes).forEach(el => element.removeChild(el));\n};\n/**\n * VIBRATE\n * Bật rung trên mobile\n * @param time\n */\nconst VIBRATE = (time = 300) => {\n  time && IS_MOBILE() && window?.navigator?.vibrate(time);\n};\n/**\n * IS_MOBILE\n * @returns\n */\nconst IS_MOBILE = () => {\n  const vendor = navigator.userAgent || navigator['vendor'] || window['opera'];\n  const phone = /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i;\n  const version = /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i;\n  const isSafari = /^((?!chrome|android).)*safari/i;\n  return !!(phone.test(vendor) || version.test(vendor.substr(0, 4))) && !isSafari.test(vendor);\n};\nlet NgxScannerQrcodeService = /*#__PURE__*/(() => {\n  class NgxScannerQrcodeService {\n    /**\n     * Load files\n     * @param files\n     * @return AsyncSubject\n     */\n    loadFiles(files = []) {\n      const as = new AsyncSubject();\n      Promise.all(Object.assign([], files).map(m => this.readAsDataURL(m))).then(img => AS_COMPLETE(as, img)).catch(error => AS_COMPLETE(as, null, error));\n      return as;\n    }\n    /**\n     * loadFilesToScan\n     * @param files\n     * @param config\n     * @returns\n     */\n    loadFilesToScan(files = [], config) {\n      return FILES_TO_SCAN(files, config);\n    }\n    /**\n     * readAsDataURL\n     * @param file\n     * @return Promise\n     */\n    readAsDataURL(file) {\n      /** drawImage **/\n      return new Promise((resolve, reject) => {\n        const fileReader = new FileReader();\n        fileReader.onload = () => {\n          const objectFile = {\n            name: file.name,\n            file: file,\n            url: URL.createObjectURL(file)\n          };\n          resolve(objectFile);\n        };\n        fileReader.onerror = error => reject(error);\n        fileReader.readAsDataURL(file);\n      });\n    }\n  }\n  NgxScannerQrcodeService.ɵfac = function NgxScannerQrcodeService_Factory(t) {\n    return new (t || NgxScannerQrcodeService)();\n  };\n  NgxScannerQrcodeService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgxScannerQrcodeService,\n    factory: NgxScannerQrcodeService.ɵfac,\n    providedIn: 'root'\n  });\n  return NgxScannerQrcodeService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgxScannerQrcodeComponent = /*#__PURE__*/(() => {\n  class NgxScannerQrcodeComponent {\n    constructor(renderer) {\n      this.renderer = renderer;\n      /**\n       * EventEmitter\n       */\n      this.event = new EventEmitter();\n      /**\n       * Input\n       */\n      this.src = CONFIG_DEFAULT.src;\n      this.fps = CONFIG_DEFAULT.fps;\n      this.vibrate = CONFIG_DEFAULT.vibrate;\n      this.decode = CONFIG_DEFAULT.decode;\n      this.isBeep = CONFIG_DEFAULT.isBeep;\n      this.config = CONFIG_DEFAULT;\n      this.constraints = CONFIG_DEFAULT.constraints;\n      this.canvasStyles = CONFIG_DEFAULT.canvasStyles;\n      /**\n       * Export\n      */\n      this.isStart = false;\n      this.isPause = false;\n      this.isLoading = false;\n      this.isTorch = false;\n      this.data = new BehaviorSubject([]);\n      this.devices = new BehaviorSubject([]);\n      this.deviceIndexActive = 0;\n      this.dataForResize = [];\n      this.ready = new AsyncSubject();\n      this.STATUS = {\n        startON: () => this.isStart = true,\n        pauseON: () => this.isPause = true,\n        loadingON: () => this.isLoading = true,\n        startOFF: () => this.isStart = false,\n        pauseOFF: () => this.isPause = false,\n        loadingOFF: () => this.isLoading = false,\n        torchOFF: () => this.isTorch = false\n      };\n    }\n    ngOnInit() {\n      this.overrideConfig();\n      ADD_JS_TO_ELEMENT(this.ready, this.renderer).subscribe(() => {\n        if (this.src) {\n          this.loadImage(this.src);\n        }\n        this.resize();\n      });\n    }\n    /**\n     * start\n     * @param playDeviceCustom\n     * @return AsyncSubject\n     */\n    start(playDeviceCustom) {\n      const as = new AsyncSubject();\n      if (this.isStart) {\n        // Reject\n        AS_COMPLETE(as, false);\n      } else {\n        // fix safari\n        this.safariWebRTC(as, playDeviceCustom);\n      }\n      return as;\n    }\n    /**\n     * stop\n     * @return AsyncSubject\n     */\n    stop() {\n      this.STATUS.pauseOFF();\n      this.STATUS.startOFF();\n      this.STATUS.torchOFF();\n      this.STATUS.loadingOFF();\n      const as = new AsyncSubject();\n      try {\n        clearInterval(this.rAF_ID);\n        this.video.nativeElement.srcObject.getTracks().forEach(track => {\n          track.stop();\n          AS_COMPLETE(as, true);\n        });\n        REMOVE_CANVAS(this.resultsPanel.nativeElement);\n      } catch (error) {\n        AS_COMPLETE(as, false, error);\n      }\n      return as;\n    }\n    /**\n     * play\n     * @return AsyncSubject\n     */\n    play() {\n      const as = new AsyncSubject();\n      if (this.isPause) {\n        this.video.nativeElement.play();\n        this.STATUS.pauseOFF();\n        this.requestAnimationFrame(90);\n        AS_COMPLETE(as, true);\n      } else {\n        AS_COMPLETE(as, false);\n      }\n      return as;\n    }\n    /**\n     * pause\n     * @return AsyncSubject\n     */\n    pause() {\n      const as = new AsyncSubject();\n      if (this.isStart) {\n        clearInterval(this.rAF_ID);\n        this.video.nativeElement.pause();\n        this.STATUS.pauseON();\n        AS_COMPLETE(as, true);\n      } else {\n        AS_COMPLETE(as, false);\n      }\n      return as;\n    }\n    /**\n     * playDevice\n     * @param deviceId\n     * @param as\n     * @return AsyncSubject\n     */\n    playDevice(deviceId, as = new AsyncSubject()) {\n      const existDeviceId = this.isStart ? this.getConstraints().deviceId !== deviceId : true;\n      switch (true) {\n        case deviceId === 'null' || deviceId === 'undefined' || !deviceId:\n          stop();\n          this.stop();\n          AS_COMPLETE(as, false);\n          break;\n        case deviceId && existDeviceId:\n          stop();\n          this.stop();\n          // Loading on\n          this.STATUS.loadingON();\n          this.deviceIndexActive = this.devices.value.findIndex(f => f.deviceId === deviceId);\n          const constraints = {\n            ...this.constraints,\n            audio: false,\n            video: {\n              deviceId: deviceId,\n              ...this.constraints.video\n            }\n          };\n          // MediaStream\n          navigator.mediaDevices.getUserMedia(constraints).then(stream => {\n            this.video.nativeElement.srcObject = stream;\n            this.video.nativeElement.onloadedmetadata = () => {\n              this.video.nativeElement.play();\n              this.requestAnimationFrame();\n              AS_COMPLETE(as, true);\n              this.STATUS.startON();\n              this.STATUS.loadingOFF();\n            };\n          }).catch(error => {\n            this.eventEmit(false);\n            AS_COMPLETE(as, false, error);\n            this.STATUS.startOFF();\n            this.STATUS.loadingOFF();\n          });\n          break;\n        default:\n          AS_COMPLETE(as, false);\n          this.STATUS.loadingOFF();\n          break;\n      }\n      return as;\n    }\n    /**\n     * loadImage\n     * @param src\n     * @return AsyncSubject\n     */\n    loadImage(src) {\n      const as = new AsyncSubject();\n      // Loading on\n      this.STATUS.startOFF();\n      this.STATUS.loadingON();\n      // Set the src of this Image object.\n      const image = new Image();\n      // Setting cross origin value to anonymous\n      image.setAttribute('crossOrigin', 'anonymous');\n      // When our image has loaded.\n      image.onload = () => {\n        this.drawImage(image, flag => {\n          AS_COMPLETE(as, flag);\n          this.STATUS.startOFF();\n          this.STATUS.loadingOFF();\n        });\n      };\n      // Set src\n      image.src = src;\n      return as;\n    }\n    /**\n     * torcher\n     * @return AsyncSubject\n     */\n    torcher() {\n      const as = this.applyConstraints({\n        advanced: [{\n          torch: this.isTorch\n        }]\n      });\n      as.subscribe(() => false, () => this.isTorch = !this.isTorch);\n      return as;\n    }\n    /**\n     * applyConstraints\n     * @param constraints\n     * @return AsyncSubject\n     */\n    applyConstraints(constraints) {\n      const as = new AsyncSubject();\n      const stream = this.video.nativeElement.srcObject;\n      const videoTrack = stream.getVideoTracks()[0];\n      const imageCapture = new window.ImageCapture(videoTrack);\n      imageCapture.getPhotoCapabilities().then( /*#__PURE__*/_asyncToGenerator(function* () {\n        yield videoTrack.applyConstraints(constraints);\n        AS_COMPLETE(as, true);\n      })).catch(error => {\n        switch (error?.name) {\n          case 'NotFoundError':\n          case 'DevicesNotFoundError':\n            AS_COMPLETE(as, false, 'Required track is missing');\n            break;\n          case 'NotReadableError':\n          case 'TrackStartError':\n            AS_COMPLETE(as, false, 'Webcam or mic are already in use');\n            break;\n          case 'OverconstrainedError':\n          case 'ConstraintNotSatisfiedError':\n            AS_COMPLETE(as, false, 'Constraints can not be satisfied by avb. devices');\n            break;\n          case 'NotAllowedError':\n          case 'PermissionDeniedError':\n            AS_COMPLETE(as, false, 'Permission denied in browser');\n            break;\n          case 'TypeError':\n            AS_COMPLETE(as, false, 'Empty constraints object');\n            break;\n          default:\n            AS_COMPLETE(as, false, error);\n            break;\n        }\n      });\n      return as;\n    }\n    /**\n     * getConstraints\n     * @returns\n     */\n    getConstraints() {\n      const stream = this.video.nativeElement.srcObject;\n      const videoTrack = stream?.getVideoTracks()[0];\n      return videoTrack?.getConstraints();\n    }\n    /**\n     * download\n     * @param fileName\n     * @return AsyncSubject\n     */\n    download(fileName = `ngx-scanner-qrcode-${Date.now()}.png`) {\n      var _this = this;\n      const as = new AsyncSubject();\n      const run = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* () {\n          const blob = yield CANVAS_TO_BLOB(_this.canvas.nativeElement);\n          const file = BLOB_TO_FILE(blob, fileName);\n          FILES_TO_SCAN([file], _this.config, as).subscribe(res => {\n            res.forEach(item => {\n              const link = document.createElement('a');\n              link.href = item.url;\n              link.download = item.name;\n              link.click();\n              link.remove();\n            });\n          });\n        });\n        return function run() {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n      run();\n      return as;\n    }\n    /**\n     * window: resize\n     * Draw again!\n     */\n    resize() {\n      window.addEventListener(\"resize\", () => {\n        if (this.dataForResize?.length) {\n          DRAW_RESULT_APPEND_CHILD(this.dataForResize, this.canvas.nativeElement, this.resultsPanel.nativeElement, this.canvasStyles);\n        }\n      });\n    }\n    /**\n     * Override config\n     * @return void\n     */\n    overrideConfig() {\n      if (this.config?.src) this.src = this.config.src;\n      if (this.config?.fps) this.fps = this.config.fps;\n      if (this.config?.vibrate) this.vibrate = this.config.vibrate;\n      if (this.config?.decode) this.decode = this.config.decode;\n      if (this.config?.isBeep) this.isBeep = this.config.isBeep;\n      if (this.config?.constraints) this.constraints = OVERRIDES('constraints', this.config, MEDIA_STREAM_DEFAULT);\n      if (this.config?.canvasStyles) this.canvasStyles = this.config.canvasStyles;\n    }\n    /**\n     * safariWebRTC\n     * Fix issue on safari\n     * https://webrtchacks.com/guide-to-safari-webrtc\n     * @param as\n     * @param playDeviceCustom\n     */\n    safariWebRTC(as, playDeviceCustom) {\n      // Loading on\n      this.STATUS.startOFF();\n      this.STATUS.loadingON();\n      navigator.mediaDevices.getUserMedia(this.constraints).then(stream => {\n        stream.getTracks().forEach(track => track.stop());\n        this.loadAllDevices(as, playDeviceCustom);\n      }).catch(error => {\n        AS_COMPLETE(as, false, error);\n        this.STATUS.startOFF();\n        this.STATUS.loadingOFF();\n      });\n    }\n    /**\n     * loadAllDevices\n     * @param as\n     * @param playDeviceCustom\n     */\n    loadAllDevices(as, playDeviceCustom) {\n      navigator.mediaDevices.enumerateDevices().then(devices => {\n        let cameraDevices = devices.filter(f => f.kind == 'videoinput');\n        this.devices.next(cameraDevices);\n        if (cameraDevices.length > 0) {\n          AS_COMPLETE(as, cameraDevices);\n          playDeviceCustom ? playDeviceCustom(cameraDevices) : this.playDevice(cameraDevices[0].deviceId);\n        } else {\n          AS_COMPLETE(as, false, 'No camera detected.');\n          this.STATUS.startOFF();\n          this.STATUS.loadingOFF();\n        }\n      }).catch(error => {\n        AS_COMPLETE(as, false, error);\n        this.STATUS.startOFF();\n        this.STATUS.loadingOFF();\n      });\n    }\n    /**\n     * drawImage\n     * @param element\n     * @param callback\n     */\n    drawImage(element, callback = () => {}) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Get the canvas element by using the getElementById method.\n        const canvas = _this2.canvas.nativeElement;\n        // Get a 2D drawing context for the canvas.\n        const ctx = canvas.getContext('2d', {\n          willReadFrequently: true\n        });\n        // HTMLImageElement size\n        if (element instanceof HTMLImageElement) {\n          canvas.width = element.naturalWidth;\n          canvas.height = element.naturalHeight;\n          element.style.visibility = '';\n          _this2.video.nativeElement.style.visibility = 'hidden';\n          _this2.video.nativeElement.style.height = canvas.offsetHeight + 'px';\n        }\n        // HTMLVideoElement size\n        if (element instanceof HTMLVideoElement) {\n          canvas.width = element.videoWidth;\n          canvas.height = element.videoHeight;\n          element.style.visibility = '';\n          _this2.canvas.nativeElement.style.visibility = 'hidden';\n        }\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw image\n        ctx.drawImage(element, 0, 0, canvas.width, canvas.height);\n        // Data image\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Draw frame\n        if (zbarWasm) {\n          const code = yield zbarWasm.scanImageData(imageData);\n          if (code?.length) {\n            // Decode\n            code.forEach(s => s.value = s.decode(_this2.decode?.toLocaleLowerCase()));\n            // Overlay\n            DRAW_RESULT_APPEND_CHILD(code, Object.freeze(_this2.canvas.nativeElement), _this2.resultsPanel.nativeElement, _this2.canvasStyles);\n            // To blob and emit data\n            const EMIT_DATA = () => {\n              _this2.eventEmit(code);\n              _this2.dataForResize = code;\n            };\n            // HTMLImageElement\n            if (element instanceof HTMLImageElement) {\n              callback(true);\n              EMIT_DATA();\n              VIBRATE(_this2.vibrate);\n              PLAY_AUDIO(_this2.isBeep);\n            }\n            // HTMLVideoElement\n            if (element instanceof HTMLVideoElement) {\n              EMIT_DATA();\n              VIBRATE(_this2.vibrate);\n              PLAY_AUDIO(_this2.isBeep);\n            }\n          } else {\n            callback(false);\n            REMOVE_CANVAS(_this2.resultsPanel.nativeElement);\n            _this2.dataForResize = code;\n          }\n        } else {\n          console.error('ngx-scanner-qrcode wasm is not found!');\n          callback(false);\n        }\n      })();\n    }\n    /**\n     * eventEmit\n     * @param response\n     */\n    eventEmit(response = false) {\n      response !== false && this.data.next(response || {\n        data: null\n      });\n      response !== false && this.event.emit(response || {\n        data: null\n      });\n    }\n    /**\n     * Single-thread\n     * Loop Recording on Camera\n     * Must be destroy request\n     * Not using: requestAnimationFrame\n     * @param delay\n     */\n    requestAnimationFrame(delay = 0) {\n      this.rAF_ID = setInterval(() => {\n        if (this.video.nativeElement.readyState === this.video.nativeElement.HAVE_ENOUGH_DATA) {\n          delay = 0;\n          this.drawImage(this.video.nativeElement);\n        }\n      }, /*avoid cache mediaStream*/delay || this.fps);\n    }\n    /**\n     * Status of wasm\n     * @return AsyncSubject\n     */\n    get isReady() {\n      return this.ready;\n    }\n    ngOnDestroy() {\n      this.pause();\n    }\n  }\n  NgxScannerQrcodeComponent.ɵfac = function NgxScannerQrcodeComponent_Factory(t) {\n    return new (t || NgxScannerQrcodeComponent)(i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  NgxScannerQrcodeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NgxScannerQrcodeComponent,\n    selectors: [[\"ngx-scanner-qrcode\"]],\n    viewQuery: function NgxScannerQrcodeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.video = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resultsPanel = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ngx-scanner-qrcode\"],\n    inputs: {\n      src: \"src\",\n      fps: \"fps\",\n      vibrate: \"vibrate\",\n      decode: \"decode\",\n      isBeep: \"isBeep\",\n      config: \"config\",\n      constraints: \"constraints\",\n      canvasStyles: \"canvasStyles\"\n    },\n    outputs: {\n      event: \"event\"\n    },\n    exportAs: [\"scanner\"],\n    decls: 6,\n    vars: 0,\n    consts: [[1, \"origin-overlay\"], [\"resultsPanel\", \"\"], [1, \"origin-canvas\"], [\"canvas\", \"\"], [\"playsinline\", \"\", 1, \"origin-video\"], [\"video\", \"\"]],\n    template: function NgxScannerQrcodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"div\", 0, 1)(2, \"canvas\", 2, 3)(4, \"video\", 4, 5);\n      }\n    },\n    styles: [\".ngx-scanner-qrcode{display:block;position:relative}.origin-overlay{width:100%;position:absolute}.origin-overlay span{z-index:2;color:red;text-align:left;position:absolute}.origin-overlay .qrcode-polygon{z-index:1;position:absolute}.origin-canvas{width:100%;position:absolute}.origin-video{width:100%;background-color:#262626}.qrcode-tooltip{z-index:3;position:absolute}.qrcode-tooltip:hover .qrcode-tooltip-temp{display:block;position:absolute}.qrcode-tooltip-temp{bottom:0;left:50%;padding:5px;color:#fff;text-align:left;display:none;max-width:450px;border-radius:5px;width:max-content;word-wrap:break-word;transform:translate(-50%);transform-style:preserve-3d;background-color:#000000d0;box-shadow:1px 1px 20px #000000e0}.qrcode-tooltip-temp .qrcode-tooltip-clipboard{cursor:pointer;margin-left:5px;fill:#fff}.qrcode-tooltip-temp .qrcode-tooltip-clipboard:active{fill:#afafaf}\\n\"],\n    encapsulation: 2\n  });\n  return NgxScannerQrcodeComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar ScannerQRCodeSymbolType = /*#__PURE__*/(() => {\n  ScannerQRCodeSymbolType = ScannerQRCodeSymbolType || {};\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_NONE\"] = 0] = \"ScannerQRCode_NONE\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_PARTIAL\"] = 1] = \"ScannerQRCode_PARTIAL\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_EAN2\"] = 2] = \"ScannerQRCode_EAN2\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_EAN5\"] = 5] = \"ScannerQRCode_EAN5\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_EAN8\"] = 8] = \"ScannerQRCode_EAN8\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_UPCE\"] = 9] = \"ScannerQRCode_UPCE\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_ISBN10\"] = 10] = \"ScannerQRCode_ISBN10\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_UPCA\"] = 12] = \"ScannerQRCode_UPCA\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_EAN13\"] = 13] = \"ScannerQRCode_EAN13\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_ISBN13\"] = 14] = \"ScannerQRCode_ISBN13\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_COMPOSITE\"] = 15] = \"ScannerQRCode_COMPOSITE\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_I25\"] = 25] = \"ScannerQRCode_I25\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_DATABAR\"] = 34] = \"ScannerQRCode_DATABAR\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_DATABAR_EXP\"] = 35] = \"ScannerQRCode_DATABAR_EXP\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_CODABAR\"] = 38] = \"ScannerQRCode_CODABAR\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_CODE39\"] = 39] = \"ScannerQRCode_CODE39\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_PDF417\"] = 57] = \"ScannerQRCode_PDF417\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_QRCODE\"] = 64] = \"ScannerQRCode_QRCODE\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_SQCODE\"] = 80] = \"ScannerQRCode_SQCODE\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_CODE93\"] = 93] = \"ScannerQRCode_CODE93\";\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_CODE128\"] = 128] = \"ScannerQRCode_CODE128\";\n  /*\n   * Please see _ScannerQRCode_get_symbol_hash() if adding\n   * anything after 128\n   */\n  /** mask for base symbol type.\n   * @deprecated in 0.11, remove this from existing code\n   */\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_SYMBOL\"] = 255] = \"ScannerQRCode_SYMBOL\";\n  /** 2-digit add-on flag.\n   * @deprecated in 0.11, a ::ScannerQRCode_EAN2 component is used for\n   * 2-digit GS1 add-ons\n   */\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_ADDON2\"] = 512] = \"ScannerQRCode_ADDON2\";\n  /** 5-digit add-on flag.\n   * @deprecated in 0.11, a ::ScannerQRCode_EAN5 component is used for\n   * 5-digit GS1 add-ons\n   */\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_ADDON5\"] = 1280] = \"ScannerQRCode_ADDON5\";\n  /** add-on flag mask.\n   * @deprecated in 0.11, GS1 add-ons are represented using composite\n   * symbols of type ::ScannerQRCode_COMPOSITE; add-on components use ::ScannerQRCode_EAN2\n   * or ::ScannerQRCode_EAN5\n   */\n  ScannerQRCodeSymbolType[ScannerQRCodeSymbolType[\"ScannerQRCode_ADDON\"] = 1792] = \"ScannerQRCode_ADDON\";\n  return ScannerQRCodeSymbolType;\n})();\nvar ScannerQRCodeConfigType = /*#__PURE__*/(() => {\n  ScannerQRCodeConfigType = ScannerQRCodeConfigType || {};\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_ENABLE\"] = 0] = \"ScannerQRCode_CFG_ENABLE\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_ADD_CHECK\"] = 1] = \"ScannerQRCode_CFG_ADD_CHECK\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_EMIT_CHECK\"] = 2] = \"ScannerQRCode_CFG_EMIT_CHECK\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_ASCII\"] = 3] = \"ScannerQRCode_CFG_ASCII\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_BINARY\"] = 4] = \"ScannerQRCode_CFG_BINARY\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_NUM\"] = 5] = \"ScannerQRCode_CFG_NUM\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_MIN_LEN\"] = 32] = \"ScannerQRCode_CFG_MIN_LEN\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_MAX_LEN\"] = 33] = \"ScannerQRCode_CFG_MAX_LEN\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_UNCERTAINTY\"] = 64] = \"ScannerQRCode_CFG_UNCERTAINTY\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_POSITION\"] = 128] = \"ScannerQRCode_CFG_POSITION\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_TEST_INVERTED\"] = 129] = \"ScannerQRCode_CFG_TEST_INVERTED\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_X_DENSITY\"] = 256] = \"ScannerQRCode_CFG_X_DENSITY\";\n  ScannerQRCodeConfigType[ScannerQRCodeConfigType[\"ScannerQRCode_CFG_Y_DENSITY\"] = 257] = \"ScannerQRCode_CFG_Y_DENSITY\";\n  return ScannerQRCodeConfigType;\n})();\nvar ScannerQRCodeOrientation = /*#__PURE__*/(() => {\n  ScannerQRCodeOrientation = ScannerQRCodeOrientation || {};\n  ScannerQRCodeOrientation[ScannerQRCodeOrientation[\"ScannerQRCode_ORIENT_UNKNOWN\"] = -1] = \"ScannerQRCode_ORIENT_UNKNOWN\";\n  ScannerQRCodeOrientation[ScannerQRCodeOrientation[\"ScannerQRCode_ORIENT_UP\"] = 0] = \"ScannerQRCode_ORIENT_UP\";\n  ScannerQRCodeOrientation[ScannerQRCodeOrientation[\"ScannerQRCode_ORIENT_RIGHT\"] = 1] = \"ScannerQRCode_ORIENT_RIGHT\";\n  ScannerQRCodeOrientation[ScannerQRCodeOrientation[\"ScannerQRCode_ORIENT_DOWN\"] = 2] = \"ScannerQRCode_ORIENT_DOWN\";\n  ScannerQRCodeOrientation[ScannerQRCodeOrientation[\"ScannerQRCode_ORIENT_LEFT\"] = 3] = \"ScannerQRCode_ORIENT_LEFT\";\n  return ScannerQRCodeOrientation;\n})();\nclass ScannerQRCodeTypePointer {\n  constructor(ptr, buf) {\n    this.ptr = ptr;\n    this.ptr32 = ptr >> 2;\n    this.buf = buf;\n    this.HEAP8 = new Int8Array(buf);\n    this.HEAPU32 = new Uint32Array(buf);\n    this.HEAP32 = new Int32Array(buf);\n  }\n}\nclass ScannerQRCodeSymbolPtr extends ScannerQRCodeTypePointer {\n  get type() {\n    return this.HEAPU32[this.ptr32];\n  }\n  get data() {\n    const len = this.HEAPU32[this.ptr32 + 4];\n    const ptr = this.HEAPU32[this.ptr32 + 5];\n    return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n  }\n  get points() {\n    const len = this.HEAPU32[this.ptr32 + 7];\n    const ptr = this.HEAPU32[this.ptr32 + 8];\n    const ptr32 = ptr >> 2;\n    const res = [];\n    for (let i = 0; i < len; ++i) {\n      const x = this.HEAP32[ptr32 + i * 2];\n      const y = this.HEAP32[ptr32 + i * 2 + 1];\n      res.push({\n        x,\n        y\n      });\n    }\n    return res;\n  }\n  get orientation() {\n    return this.HEAP32[this.ptr32 + 9];\n  }\n  get next() {\n    const ptr = this.HEAPU32[this.ptr32 + 11];\n    if (!ptr) return null;\n    return new ScannerQRCodeSymbolPtr(ptr, this.buf);\n  }\n  get time() {\n    return this.HEAPU32[this.ptr32 + 13];\n  }\n  get cacheCount() {\n    return this.HEAP32[this.ptr32 + 14];\n  }\n  get quality() {\n    return this.HEAP32[this.ptr32 + 15];\n  }\n}\nclass SymbolSetPtr extends ScannerQRCodeTypePointer {\n  get head() {\n    const ptr = this.HEAPU32[this.ptr32 + 2];\n    if (!ptr) return null;\n    return new ScannerQRCodeSymbolPtr(ptr, this.buf);\n  }\n}\nclass ScannerQRCodeResult {\n  constructor(ptr) {\n    this.value = '';\n    this.type = ptr.type;\n    this.typeName = ScannerQRCodeSymbolType[this.type];\n    this.data = ptr.data;\n    this.points = ptr.points;\n    this.orientation = ptr.orientation;\n    this.time = ptr.time;\n    this.cacheCount = ptr.cacheCount;\n    this.quality = ptr.quality;\n  }\n  static createSymbolsFromPtr(ptr, buf) {\n    if (ptr == 0) return [];\n    const set = new SymbolSetPtr(ptr, buf);\n    let symbol = set.head;\n    const res = [];\n    while (symbol !== null) {\n      res.push(new ScannerQRCodeResult(symbol));\n      symbol = symbol.next;\n    }\n    return res;\n  }\n  decode(encoding) {\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(this.data);\n  }\n}\nlet NgxScannerQrcodeModule = /*#__PURE__*/(() => {\n  class NgxScannerQrcodeModule {}\n  NgxScannerQrcodeModule.ɵfac = function NgxScannerQrcodeModule_Factory(t) {\n    return new (t || NgxScannerQrcodeModule)();\n  };\n  NgxScannerQrcodeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NgxScannerQrcodeModule\n  });\n  NgxScannerQrcodeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [NgxScannerQrcodeService]\n  });\n  return NgxScannerQrcodeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-scanner-qrcode\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxScannerQrcodeComponent, NgxScannerQrcodeModule, NgxScannerQrcodeService, ScannerQRCodeConfigType, ScannerQRCodeOrientation, ScannerQRCodeResult, ScannerQRCodeSymbolType };\n//# sourceMappingURL=ngx-scanner-qrcode.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}